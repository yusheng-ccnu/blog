---
title: nim游戏解法
date: 2018-09-04 21:17:26
tags: 
- 算法
- 招商银行
- Nim游戏
categories:
- 面试算法
---
### Nim游戏及变种的算法题目
#### Nim游戏简介

> 有若干堆石子，每堆石子的数量都是有限的，合法的移动是“选择一堆石子并拿走若干颗（不能不拿）”，如果轮到某个人时所有的石子堆都已经被拿空了，则判负（因为他此刻没有任何合法的移动）。当然还有反Nim游戏，即拿到最后一个石子的人输。

在求解Nim游戏前，我们给出P-position和N-position的定义：给出若干组二进制数，其二进制位对齐排列，把各列相加，如果各列得到的数字是偶数，那么它就是一个。以这个情况开局，或者在之后的某一手中，当前是一个安全组合，先手的人无论作出什么改变，都将使这个组合变为一个不安全的组合，而后手的人又总能由不安全的组合拼凑出一个安全的组合，我们称此时先手必败（后手必胜），这个局面称之为**P-position**，反之，若面临的是一个不安全组合，则其总有办法变为一个安全的组合，到下一个人进行时无论怎么改变都将成为一个不安全组合，此时后手必败（先手必胜），这个局面称之为**N-position**。

一下证明部分摘自知乎：https://www.zhihu.com/people/simonshao/activities

> 要知道，像Nim游戏这种博弈问题，最重要的是寻找必败态。这个必败态的的意思就是，这样一种局面摆在面前的话先手必败。其严格定义如下：1、无法进行任何移动的局面是必败态；2、可以移动到必败态的局面是非必败态；3、在必败态做的所有操作的结果都是非必败态。这个还是很好理解的吧，就是自己处在非必败态上总能移动到必败态把必败态留给对方，而对方处在必败态的话总是只能移动到非必败态，把非必败态留给自己，然后自己继续虐对方。

证明：

> + 第一个命题显然，最终局面只有一个，就是全0，a1^a2^...^ai'^...^an = 0。
>
> + 第二个命题，对于某个局面(a1,a2,...,an)，若a1^a2^...^an不为0，一定存在某个合法的移动，将ai改变成ai'后满足a1^a2^...^ai'^...^an=0。不妨设a1^a2^...^an=k，则一定存在某个ai，它的二进制表示在k的最高位上是1（否则k的最高位那个1是怎么得到的）。这时ai^k&lt;ai一定成立。则我们可以将ai改变成ai'=ai^k，此时a1^a2^...^ai'^...^an=a1^a2^...^an^k=0。
>
> + 第三个命题，对于某个局面(a1,a2,...,an)，若a1^a2^...^an=0，一定不存在某个合法的移动，将ai改变成ai'后满足a1^a2^...^ai'^...^an=0。因为异或运算满足消去率，由a1^a2^...^an=a1^a2^...^ai'^...^an可以得到ai=ai'。所以将ai改变成ai'不是一个合法的移动。证毕。根据这个定理，我们可以在O(n)的时间内判断一个Nim的局面的性质，且如果它是N-position，也可以在O(n)的时间内找到所有的必胜策略。Nim问题就这样基本上完美的解决了。

#### Nim游戏衍生的算法题目

##### 题目描述

> 按照卡中心校园招聘的要求，HR小招和小商需要从三个科室中（分别为A、B、C）抽派面试官去往不同城市。
> 两名HR按照以下规定轮流从任一科室选择面试官：每次至少选择一位，至多选择该科室剩余面试官数。最先选不到面试官的HR需要自己出差。
> 假设HR小招和小商都不想出差且每次选择都采取最优策略，如果是小招先选，写一个函数来判断她是否需要出差。如果不需要出差，请给出第一步的最优策略。

##### 题目分析

从上述Nim游戏的简介不难看出，这个题目也是Nim游戏问题，对于这个题目若A ^ B ^ C = 0，小招就是必败态，否则就得选择一定的数量的面试官，转移到必败态给小商选择。为了使选择之后A ^ B ^ C = 0，枚举两两的异或和，只有第三个的值大于这个异或值，选择第三个值减去另外两个数的异或值的差就可以保证获胜。

##### 代码示例

```java
import java.util.Scanner;

public class Nim {
    public static void main(String args[]){
        Scanner scanner = new Scanner(System.in);
        String inputData = scanner.nextLine();
        String nums[] = inputData.split(",");
        int A = Integer.parseInt(nums[0]);
        int B = Integer.parseInt(nums[1]);
        int C = Integer.parseInt(nums[2]);

        int isOnBusiness = A ^ B ^ C;

        if (isOnBusiness == 0) {
            System.out.println(1);
            return;
        }

        if ((A ^ B) < C ) {
            System.out.println("C," + (C - (A ^ B)) );
        }

        if ((A ^ C) < B) {
            System.out.println("B," + (B - (A ^ C)) );
        }

        if ((B ^ C) < A) {
            System.out.println("A," + (A - (B ^ C)) );
        }

    }
}

```





